# YouTube downloader utility for VCPlay Music Bot

import asyncio
import os
import re
import aiofiles
from typing import List, Dict, Optional
import yt_dlp
import config

class YouTubeDownloader:
    def __init__(self):
        self.ydl_opts = {
            'format': 'best[height<=720]/best',
            'extractaudio': True,
            'audioformat': 'mp3',
            'outtmpl': f'{config.DOWNLOAD_DIR}/%(title)s.%(ext)s',
            'nocheckcertificate': True,
            'ignoreerrors': False,
            'logtostderr': False,
            'quiet': True,
            'no_warnings': True,
            'writethumbnail': False,
            'writeinfojson': False,
            'cookiefile': None,
        }
        
        self.audio_opts = {
            **self.ydl_opts,
            'format': 'bestaudio[ext=m4a]/bestaudio',
            'extractaudio': True,
            'audioformat': 'mp3',
            'audioquality': '192K',
        }
        
        self.video_opts = {
            **self.ydl_opts,
            'format': 'best[height<=720]/best',
            'extractaudio': False,
        }
        
        self.playlist_opts = {
            **self.ydl_opts,
            'extract_flat': True,
            'dump_single_json': True,
        }
    
    async def search_youtube(self, query: str, video: bool = False, limit: int = 1) -> List[Dict]:
        """Search YouTube for videos/audio"""
        try:
            search_query = f"ytsearch{limit}:{query}"
            
            ydl_opts = self.video_opts if video else self.audio_opts
            ydl_opts['quiet'] = True
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                search_results = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: ydl.extract_info(search_query, download=False)
                )
            
            if not search_results or 'entries' not in search_results:
                return []
            
            results = []
            for entry in search_results['entries'][:limit]:
                if entry:
                    result = {
                        'title': entry.get('title', 'Unknown'),
                        'duration': entry.get('duration', 0),
                        'url': entry.get('webpage_url', ''),
                        'thumbnail': self._get_best_thumbnail(entry.get('thumbnails', [])),
                        'uploader': entry.get('uploader', 'Unknown'),
                        'view_count': entry.get('view_count', 0),
                        'id': entry.get('id', ''),
                    }
                    results.append(result)
            
            return results
        
        except Exception as e:
            print(f"Search error: {e}")
            return []
    
    def _get_best_thumbnail(self, thumbnails: List[Dict]) -> str:
        """Get the best quality thumbnail URL"""
        if not thumbnails:
            return config.THUMBNAIL_URL
        
        # Sort by width (descending)
        sorted_thumbs = sorted(
            thumbnails, 
            key=lambda x: x.get('width', 0), 
            reverse=True
        )
        
        return sorted_thumbs[0].get('url', config.THUMBNAIL_URL)
    
    async def download_audio(self, url: str) -> Optional[str]:
        """Download audio from YouTube URL"""
        try:
            filename = None
            
            def progress_hook(d):
                nonlocal filename
                if d['status'] == 'finished':
                    filename = d['filename']
            
            self.audio_opts['progress_hooks'] = [progress_hook]
            
            with yt_dlp.YoutubeDL(self.audio_opts) as ydl:
                await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: ydl.download([url])
                )
            
            # Convert to mp3 if needed
            if filename and not filename.endswith('.mp3'):
                mp3_filename = filename.rsplit('.', 1)[0] + '.mp3'
                
                # Convert using ffmpeg
                ffmpeg_cmd = [
                    'ffmpeg', '-i', filename, 
                    '-acodec', 'libmp3lame', 
                    '-ab', '192k',
                    '-y', mp3_filename
                ]
                
                process = await asyncio.create_subprocess_exec(
                    *ffmpeg_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
                
                # Remove original file
                if os.path.exists(filename):
                    os.remove(filename)
                
                filename = mp3_filename
            
            return filename
        
        except Exception as e:
            print(f"Audio download error: {e}")
            return None
    
    async def download_video(self, url: str) -> Optional[str]:
        """Download video from YouTube URL"""
        try:
            filename = None
            
            def progress_hook(d):
                nonlocal filename
                if d['status'] == 'finished':
                    filename = d['filename']
            
            self.video_opts['progress_hooks'] = [progress_hook]
            
            with yt_dlp.YoutubeDL(self.video_opts) as ydl:
                await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: ydl.download([url])
                )
            
            return filename
        
        except Exception as e:
            print(f"Video download error: {e}")
            return None
    
    async def get_video_info(self, url: str) -> Optional[Dict]:
        """Get video information without downloading"""
        try:
            with yt_dlp.YoutubeDL(self.ydl_opts) as ydl:
                info = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: ydl.extract_info(url, download=False)
                )
            
            if info:
                return {
                    'title': info.get('title', 'Unknown'),
                    'duration': info.get('duration', 0),
                    'thumbnail': self._get_best_thumbnail(info.get('thumbnails', [])),
                    'uploader': info.get('uploader', 'Unknown'),
                    'view_count': info.get('view_count', 0),
                    'url': info.get('webpage_url', url),
                    'id': info.get('id', ''),
                    'description': info.get('description', '')[:200] + '...' if info.get('description') else ''
                }
            
            return None
        
        except Exception as e:
            print(f"Info extraction error: {e}")
            return None
    
    async def get_playlist(self, url: str) -> Optional[Dict]:
        """Get playlist information and entries"""
        try:
            with yt_dlp.YoutubeDL(self.playlist_opts) as ydl:
                playlist_info = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: ydl.extract_info(url, download=False)
                )
            
            if playlist_info and 'entries' in playlist_info:
                # Get detailed info for each entry
                entries = []
                for entry in playlist_info['entries'][:config.PLAYLIST_LIMIT]:
                    if entry:
                        # Get full info for each video
                        video_info = await self.get_video_info(entry['url'])
                        if video_info:
                            entries.append(video_info)
                
                return {
                    'title': playlist_info.get('title', 'Unknown Playlist'),
                    'uploader': playlist_info.get('uploader', 'Unknown'),
                    'entries': entries,
                    'entry_count': len(entries)
                }
            
            return None
        
        except Exception as e:
            print(f"Playlist extraction error: {e}")
            return None
    
    def is_youtube_url(self, url: str) -> bool:
        """Check if URL is a valid YouTube URL"""
        youtube_regex = re.compile(
            r'^(https?://)?(www\.)?(youtube|youtu|youtube-nocookie)\.(com|be)/'
            r'(watch\?v=|embed/|v/|.+\?v=)?([^&=%\?]{11})'
        )
        return bool(youtube_regex.match(url))
    
    def is_playlist_url(self, url: str) -> bool:
        """Check if URL is a YouTube playlist URL"""
        return 'list=' in url
    
    def extract_video_id(self, url: str) -> Optional[str]:
        """Extract video ID from YouTube URL"""
        youtube_regex = re.compile(
            r'(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})'
        )
        match = youtube_regex.search(url)
        return match.group(1) if match else None
    
    async def get_stream_url(self, url: str, audio_only: bool = True) -> Optional[str]:
        """Get direct stream URL for live streaming"""
        try:
            format_selector = 'bestaudio' if audio_only else 'best[height<=720]'
            
            opts = {
                **self.ydl_opts,
                'format': format_selector,
                'quiet': True,
                'no_warnings': True,
            }
            
            with yt_dlp.YoutubeDL(opts) as ydl:
                info = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: ydl.extract_info(url, download=False)
                )
            
            if info and 'url' in info:
                return info['url']
            
            return None
        
        except Exception as e:
            print(f"Stream URL extraction error: {e}")
            return None
    
    async def search_spotify_track(self, track_name: str, artist: str = "") -> Optional[str]:
        """Search for Spotify track on YouTube"""
        if artist:
            query = f"{artist} - {track_name} official"
        else:
            query = f"{track_name} official"
        
        results = await self.search_youtube(query, limit=1)
        return results[0]['url'] if results else None
    
    async def cleanup_downloads(self):
        """Clean up old downloaded files"""
        try:
            if not os.path.exists(config.DOWNLOAD_DIR):
                return
            
            current_time = asyncio.get_event_loop().time()
            
            for filename in os.listdir(config.DOWNLOAD_DIR):
                file_path = os.path.join(config.DOWNLOAD_DIR, filename)
                
                if os.path.isfile(file_path):
                    # Delete files older than cleanup interval
                    file_age = current_time - os.path.getctime(file_path)
                    
                    if file_age > config.CLEANUP_INTERVAL:
                        os.remove(file_path)
                        print(f"Cleaned up: {filename}")
        
        except Exception as e:
            print(f"Cleanup error: {e}")
    
    def format_duration(self, seconds: int) -> str:
        """Format duration from seconds to readable format"""
        if seconds == 0:
            return "Unknown"
        
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        seconds = seconds % 60
        
        if hours > 0:
            return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        else:
            return f"{minutes:02d}:{seconds:02d}"
